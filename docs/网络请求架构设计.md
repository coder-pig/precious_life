# 🦄 网络请求架构设计（多API服务，Dio封装，ApiClient升级版）

本设计适用于需要对接多个不同网站API的Flutter/Dart项目，采用Dio进行网络请求封装，结构清晰、易扩展、易维护。

---

## 1. 架构核心思想

- **多API服务支持**：通过`ApiServiceType`枚举区分不同API服务。
- **统一ApiClient管理**：`NetworkManager`集中管理所有ApiClient实例，每个ApiClient可自定义baseUrl、headers、拦截器、转换器等。
- **请求/响应抽象**：定义`ApiRequest`和`ApiResponse`基类，便于统一处理和扩展。
- **Service分层**：每个API服务单独写Service类，专注业务逻辑。
- **拦截器与通用配置**：全局拦截器统一配置，特殊需求可单独处理。
- **灵活拦截器机制**：支持日志打印、鉴权、错误处理等多种拦截器，可按需配置。

---

## 2. 目录结构建议

```
lib/
  network/
    api_service_type.dart      // API服务类型枚举
    api_client.dart            // ApiClient配置类
    network_manager.dart       // 统一管理ApiClient实例
    interceptors.dart          // 拦截器实现
    api_request.dart           // 请求抽象基类
    api_response.dart          // 响应抽象基类
    services/
      main_service.dart        // 主API服务
      weather_service.dart     // 天气API服务
  models/
    user_info_response.dart    // 用户信息响应模型
    ...
```

---

## 3. 代码示例

### 3.1 ApiServiceType 枚举
```dart
// api_service_type.dart
/// API服务类型枚举，用于区分不同的API服务
enum ApiServiceType {
  main,      // 主API
  weather,   // 天气API
  auth,      // 认证API
}
```

### 3.2 ApiClient 配置类
```dart
// api_client.dart
import 'package:dio/dio.dart';

/// 请求转换器类型定义
typedef RequestTransformer = dynamic Function(dynamic data);

/// 响应转换器类型定义
typedef ResponseTransformer<T> = T Function(dynamic data);

/// ApiClient 封装了API服务的所有配置
class ApiClient {
  /// 基础URL
  final String baseUrl;
  /// 请求头
  final Map<String, String> headers;
  /// 请求转换器
  final RequestTransformer? requestTransformer;
  /// 响应转换器
  final ResponseTransformer? responseTransformer;
  /// 拦截器列表
  final List<Interceptor> interceptors;
  /// 超时时间（毫秒）
  final int connectTimeout;
  final int receiveTimeout;
  final int sendTimeout;

  ApiClient({
    required this.baseUrl,
    this.headers = const {},
    this.requestTransformer,
    this.responseTransformer,
    this.interceptors = const [],
    this.connectTimeout = 15000,
    this.receiveTimeout = 15000,
    this.sendTimeout = 15000,
  });

  /// 获取配置好的Dio实例
  Dio get dio {
    final dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      headers: headers,
      connectTimeout: Duration(milliseconds: connectTimeout),
      receiveTimeout: Duration(milliseconds: receiveTimeout),
      sendTimeout: Duration(milliseconds: sendTimeout),
    ));
    
    // 添加拦截器
    for (final i in interceptors) {
      dio.interceptors.add(i);
    }
    
    return dio;
  }
}
```

### 3.3 拦截器实现
```dart
// interceptors.dart
import 'package:dio/dio.dart';

/// 拦截器工厂，提供各种常用拦截器实例
class InterceptorFactory {
  /// 创建日志拦截器
  static LogInterceptor createLogInterceptor({
    bool requestBody = true,
    bool responseBody = true,
  }) {
    return LogInterceptor(
      requestHeader: true,
      requestBody: requestBody,
      responseHeader: true,
      responseBody: responseBody,
      logPrint: (log) {
        // 可以替换成自己的日志打印方式
        print('🌐 HTTP: $log');
      }
    );
  }

  /// 创建鉴权拦截器
  static AuthInterceptor createAuthInterceptor(
    String Function() tokenGetter,
  ) {
    return AuthInterceptor(tokenGetter);
  }
  
  /// 创建错误处理拦截器
  static ErrorInterceptor createErrorInterceptor() {
    return ErrorInterceptor();
  }
}

/// 鉴权拦截器，为请求自动添加Token等认证信息
class AuthInterceptor extends Interceptor {
  final String Function() _getToken;
  
  AuthInterceptor(this._getToken);
  
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // 获取token
    final token = _getToken();
    if (token.isNotEmpty) {
      // 添加Authorization头
      options.headers['Authorization'] = 'Bearer $token';
    }
    return super.onRequest(options, handler);
  }
}

/// 错误处理拦截器，统一处理错误响应
class ErrorInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // 统一处理错误
    switch (err.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        err = _handleTimeoutError(err);
        break;
      case DioExceptionType.badResponse:
        err = _handleResponseError(err);
        break;
      default:
        err = _handleDefaultError(err);
    }
    
    // 继续传递错误
    return super.onError(err, handler);
  }
  
  /// 处理超时错误
  DioException _handleTimeoutError(DioException err) {
    return err.copyWith(
      error: '网络连接超时，请检查网络设置',
    );
  }
  
  /// 处理服务器响应错误
  DioException _handleResponseError(DioException err) {
    final statusCode = err.response?.statusCode;
    
    if (statusCode == 401) {
      // 处理未授权错误
      return err.copyWith(
        error: '登录信息已过期，请重新登录',
      );
    } else if (statusCode == 403) {
      return err.copyWith(
        error: '没有权限访问该资源',
      );
    } else if (statusCode == 404) {
      return err.copyWith(
        error: '请求的资源不存在',
      );
    } else if (statusCode! >= 500) {
      return err.copyWith(
        error: '服务器错误，请稍后再试',
      );
    }
    
    return err;
  }
  
  /// 处理默认错误
  DioException _handleDefaultError(DioException err) {
    return err.copyWith(
      error: '发生未知错误，请稍后再试',
    );
  }
}
```

### 3.4 NetworkManager
```dart
// network_manager.dart
import 'api_service_type.dart';
import 'api_client.dart';
import 'interceptors.dart';
import 'package:dio/dio.dart';

/// 统一管理不同API服务的ApiClient
class NetworkManager {
  static final Map<ApiServiceType, ApiClient> _clientMap = {};
  
  /// 是否在所有API中启用日志
  static bool enableLog = true;
  
  /// 获取Token函数
  static String Function() tokenGetter = () => '';
  
  /// 获取指定类型的ApiClient实例
  static ApiClient getClient(ApiServiceType type) {
    if (!_clientMap.containsKey(type)) {
      _clientMap[type] = _createClient(type);
    }
    return _clientMap[type]!;
  }

  /// 根据API类型创建对应的ApiClient
  static ApiClient _createClient(ApiServiceType type) {
    // 通用拦截器列表
    final List<Interceptor> interceptors = [];
    
    // 添加通用拦截器
    if (enableLog) {
      interceptors.add(InterceptorFactory.createLogInterceptor());
    }
    
    // 添加错误拦截器
    interceptors.add(InterceptorFactory.createErrorInterceptor());
    
    switch (type) {
      case ApiServiceType.main:
        return ApiClient(
          baseUrl: 'https://api.main.com',
          headers: {'Content-Type': 'application/json'},
          requestTransformer: (data) => data,
          responseTransformer: (data) => data,
          interceptors: [
            ...interceptors,
            // 添加鉴权拦截器
            InterceptorFactory.createAuthInterceptor(tokenGetter),
          ],
        );
      case ApiServiceType.weather:
        return ApiClient(
          baseUrl: 'https://api.weather.com',
          headers: {'Content-Type': 'application/json'},
          requestTransformer: (data) => data,
          responseTransformer: (data) => data,
          interceptors: interceptors,  // 不需要鉴权
        );
      case ApiServiceType.auth:
        return ApiClient(
          baseUrl: 'https://api.auth.com',
          headers: {'Content-Type': 'application/json'},
          interceptors: interceptors,  // 认证服务一般不需要鉴权拦截器
          // 认证服务可能需要更短的超时时间
          connectTimeout: 10000,
        );
    }
  }
  
  /// 设置Token获取函数
  static void setTokenGetter(String Function() getter) {
    tokenGetter = getter;
  }
  
  /// 清除ApiClient缓存
  static void clearClients() {
    _clientMap.clear();
  }
}
```

### 3.5 请求/响应抽象
```dart
// api_request.dart
/// 请求抽象基类，所有请求需继承本类
abstract class ApiRequest {
  /// 请求路径
  String get path;
  /// 请求方法（GET/POST等）
  String get method;
  /// 请求参数
  Map<String, dynamic> get params;
}

// api_response.dart
/// 响应抽象基类，所有响应需继承本类
abstract class ApiResponse {
  /// 通过json构造响应对象
  ApiResponse.fromJson(Map<String, dynamic> json);
}
```

### 3.6 具体请求/响应模型
```dart
// user_info_request.dart
import '../network/api_request.dart';

/// 获取用户信息请求
class UserInfoRequest extends ApiRequest {
  @override
  String get path => '/user/info';
  @override
  String get method => 'GET';
  @override
  Map<String, dynamic> get params => {};
}

// user_info_response.dart
import '../network/api_response.dart';

/// 用户信息响应模型
class UserInfoResponse extends ApiResponse {
  final String name;
  final int age;

  UserInfoResponse({required this.name, required this.age});

  factory UserInfoResponse.fromJson(Map<String, dynamic> json) =>
      UserInfoResponse(
        name: json['name'],
        age: json['age'],
      );
}
```

### 3.7 Service 层示例
```dart
// main_service.dart
import '../network/api_service_type.dart';
import '../network/network_manager.dart';

class MainService {
  final ApiClient _client = NetworkManager.getClient(ApiServiceType.main);

  /// 获取用户信息
  Future<dynamic> getUserInfo() async {
    final dio = _client.dio;
    final response = await dio.get('/user/info');
    // 使用自定义响应转换器
    return _client.responseTransformer?.call(response.data) ?? response.data;
  }
}
```

---

## 4. 使用示例

### 4.1 应用启动时配置
```dart
void main() {
  // 配置是否启用日志
  NetworkManager.enableLog = true;
  
  // 配置获取Token的函数
  NetworkManager.setTokenGetter(() {
    // 从本地存储或其他地方获取Token
    return '存储的Token';
  });
  
  runApp(MyApp());
}
```

### 4.2 使用Service发送请求
```dart
final mainService = MainService();

void fetchUserInfo() async {
  try {
    final userInfo = await mainService.getUserInfo();
    print('获取到用户信息: $userInfo');
  } catch (e) {
    print('获取用户信息失败: $e');
  }
}
```

---

## 5. 优点总结

- 🐱‍🏍 每个API服务可独立配置baseUrl、headers、拦截器、转换器，灵活应对各种需求。
- (｡･ω･｡)ﾉ♡ 强大的拦截器机制，轻松处理鉴权、日志、错误等场景。
- (๑•̀ㅂ•́)و✧ 结构清晰，后续扩展更方便。
- (｡•ㅅ•｡)♡ 依然支持请求/响应抽象，便于统一处理。
- (ﾉ≧∀≦)ﾉ 超时配置灵活，不同API服务可配置不同的超时时间。

---

如需更详细的实现或有特殊需求，欢迎随时交流！(づ｡◕‿‿◕｡)づ
