# 🦄 网络请求架构设计（多API服务，Dio封装，ApiClient升级版）

本设计适用于需要对接多个不同网站API的Flutter/Dart项目，采用Dio进行网络请求封装，结构清晰、易扩展、易维护。

---

## 1. 架构核心思想

- **多API服务支持**：为不同API服务创建单独的ApiClient。
- **统一异常处理**：通过`ApiException`统一处理各类网络异常。
- **API服务分层**：每个API服务单独创建对应目录，包含client、service、model等。
- **拦截器与通用配置**：全局拦截器统一配置，特殊需求可单独处理。
- **统一请求接口**：请求统一通过service类方法调用，方便管理和维护。
- **调试支持**：针对Debug模式自动添加日志打印和本地代理抓包功能。

---

## 2. 目录结构建议

```
lib/
  core/
    network/
      api_client.dart            // ApiClient配置基类
      api_exception.dart         // 异常处理基类及子类
      api/
        qweather/                // 和风天气API
          qweather_api_client.dart   // 专用客户端配置
          qweather_api_service.dart  // API服务方法
          qweather_api_model.dart    // 数据模型定义
          qweather_api_model.g.dart  // 生成的序列化代码
          qweather_api_model.freezed.dart  // 生成的不可变类
        other_api/               // 其他API服务
          ...
  config/
    app_config.dart              // 应用配置，包含API密钥、BaseURL等
```

---

## 3. 代码示例

### 3.1 ApiClient 配置类
```dart
// api_client.dart
import 'dart:io';

import 'package:dio/dio.dart';
import 'package:dio/io.dart';
import 'package:flutter/foundation.dart';

/// API客户端封装了API服务的所有配置
class ApiClient {
  final String baseUrl; // 基础URL
  final Map<String, String> headers; // 请求头
  final List<Interceptor> interceptors; // 拦截器列表
  final int connectTimeout; // 连接超时时间（毫秒）
  final int receiveTimeout; // 接收超时时间（毫秒）
  final int sendTimeout; // 发送超时时间（毫秒）

  ApiClient({
    required this.baseUrl,
    this.headers = const {},
    this.interceptors = const [],
    this.connectTimeout = 15 * Duration.millisecondsPerSecond,
    this.receiveTimeout = 15 * Duration.millisecondsPerSecond,
    this.sendTimeout = 15 * Duration.millisecondsPerSecond,
  });

  /// 获取配置好的Dio实例
  Dio get dio {
    final dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      headers: headers,
      connectTimeout: Duration(milliseconds: connectTimeout),
      receiveTimeout: Duration(milliseconds: receiveTimeout),
      sendTimeout: Duration(milliseconds: sendTimeout),
    ));
    for (final i in interceptors) {
      dio.interceptors.add(i);
    }
    if (kDebugMode) {
      // 开始时添加日志打印和抓包
      dio.interceptors.add(LogInterceptor(
        requestHeader: true,
        requestBody: true,
        responseHeader: true,
        responseBody: true,
        logPrint: (log) {
          print('🌐 HTTP: $log');
        },
      ));
      dio.httpClientAdapter = IOHttpClientAdapter(createHttpClient: () => localProxyHttpClient());
    }
    return dio;
  }
}

/// 本地代理抓包拦截器
HttpClient localProxyHttpClient() {
  return HttpClient()
    // 将请求代理到 本机IP:8888，是抓包电脑的IP
    ..findProxy = (uri) {
      return 'PROXY 192.168.102.108:8888';
    }
    // 抓包工具一般会提供一个自签名的证书，这里需要禁用证书校验
    ..badCertificateCallback = (X509Certificate cert, String host, int port) => true;
}
```

### 3.2 异常处理类
```dart
// api_exception.dart
import 'dart:io';

import 'package:dio/dio.dart';

/// 自定义请求异常父类
class ApiException implements Exception {
  final int? code;
  final String? message;
  String? stackInfo;

  ApiException([this.code, this.message]);

  factory ApiException.fromDioException(DioException exception) {
    switch (exception.type) {
      case DioExceptionType.connectionTimeout:
        return BadRequestException(-1, "连接超时");
      case DioExceptionType.sendTimeout:
        return BadRequestException(-1, "请求超时");
      case DioExceptionType.receiveTimeout:
        return BadRequestException(-1, "响应超时");
      case DioExceptionType.cancel:
        return BadRequestException(-1, "请求取消");
      case DioExceptionType.badResponse:
        int? errorCode = exception.response?.statusCode;
        switch (errorCode) {
          case 400:
            return BadRequestException(errorCode, "请求语法错误");
          case 401:
            return UnauthorisedException(errorCode, "没有权限");
          case 403:
            return UnauthorisedException(errorCode, "服务器拒绝执行");
          case 404:
            return UnauthorisedException(errorCode, "请求资源不存在");
          // 其他状态码处理...
          default:
            return ApiException(errorCode, exception.response?.statusMessage ?? '未知错误');
        }
      case DioExceptionType.connectionError:
        if (exception.error is SocketException) {
          return DisconnectException(-1, "网络未连接");
        } else {
          return ApiException(-1, "连接错误");
        }
      // 其他异常类型处理...
      default:
        return ApiException(-1, "未知错误");
    }
  }

  // 将各种异常转换为ApiException方便进行统一处理
  factory ApiException.from(dynamic exception) {
    if (exception is DioException) {
      return ApiException.fromDioException(exception);
    } else if (exception is ApiException) {
      return exception;
    } else {
      return ApiException(-1, "未知错误")..stackInfo = exception.toString();
    }
  }
}

/// 错误请求异常
class BadRequestException extends ApiException {
  BadRequestException(super.code, super.message);
}

/// 网络未连接异常
class DisconnectException extends ApiException {
  DisconnectException(super.code, super.message);
}

/// 未认证异常
class UnauthorisedException extends ApiException {
  UnauthorisedException(super.code, super.message);
}
```

### 3.3 特定API客户端
```dart
// qweather_api_client.dart
import 'package:dio/dio.dart';
import 'package:precious_life/config/app_config.dart';
import 'package:precious_life/core/network/api_client.dart';

/// 和风天气API客户端
/// 负责和风天气API的请求处理，使用单例模式
class QweatherApiClient {
  /// 单例
  QweatherApiClient._();
  static final QweatherApiClient _instance = QweatherApiClient._();
  static QweatherApiClient get instance => _instance;

  /// API客户端实例
  late final ApiClient _apiClient = ApiClient(
    baseUrl: AppConfig.qweatherBaseUrl,
    headers: {'Content-Type': 'application/json'},
    interceptors: [
      _QweatherApiInterceptor(),
    ],
  );
  Dio get dio => _apiClient.dio;
}

/// 和风天气API拦截器
class _QweatherApiInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    /// 为每个请求添加必要的参数，如API密钥
    options.headers.addAll({
      'X-QW-Api-Key': AppConfig.qweatherApiKey,
    });
    super.onRequest(options, handler);
  }
}
```

### 3.4 API服务类
```dart
// qweather_api_service.dart
import 'package:precious_life/core/network/api/qweather/qweather_api_client.dart';
import 'package:precious_life/core/network/api/qweather/qweather_api_model.dart';
import '../../api_exception.dart';

/// 和风天气API服务类
/// 提供一系列发起请求的静态方法
class QweatherApiService {
  /// 城市信息查询接口
  ///
  /// 通过城市名称或经纬度坐标查询城市信息
  ///
  /// [location] 城市名称、ID或经纬度坐标，例如：'深圳'、'101280604'或'113.92,22.53'
  static Future<QweatherCityResponse> lookupCity(String location) async {
    try {
      final resp = await QweatherApiClient.instance.dio.get(
        '/geo/v2/city/lookup',
        queryParameters: {'location': location},
      );
      final respJson = resp.data;
      if (respJson['error'] != null) {
        throw ApiException(respJson['error']['status'], respJson['error']['detail']);
      }
      if (respJson['code'] != '200') {
        throw ApiException(respJson['code'], respJson['message']);
      }
      return QweatherCityResponse.fromJson(respJson);
    } catch (e) {
      throw ApiException.from(e);
    }
  }
}
```

---

## 4. 使用示例

### 4.1 在应用中发起API请求
```dart
import 'package:precious_life/core/network/api/qweather/qweather_api_service.dart';

Future<void> getWeatherInfo() async {
  try {
    // 查询城市信息
    final cityResponse = await QweatherApiService.lookupCity('深圳');
    print('获取到城市信息: ${cityResponse.location.first.name}');
    
    // 可以继续发起天气查询等
  } catch (e) {
    print('获取天气信息失败: $e');
  }
}
```

### 4.2 配置API密钥和基础URL
```dart
// config/app_config.dart
class AppConfig {
  // 和风天气API配置
  static const String qweatherBaseUrl = 'https://api.qweather.com';
  static const String qweatherApiKey = 'your_api_key_here';
  
  // 其他API服务配置
  // ...
}
```

---

## 5. 优点总结

- 🐱‍🏍 各API服务独立封装，互不干扰，方便维护和扩展。
- (｡･ω･｡)ﾉ♡ 统一的异常处理机制，便于全局错误管理。
- (๑•̀ㅂ•́)و✧ Debug模式自动添加日志和抓包功能，方便调试。
- (｡•ㅅ•｡)♡ 单例模式避免重复创建客户端实例，提高性能。
- (ﾉ≧∀≦)ﾉ 结构清晰，职责分明，易于理解和维护。
- (づ｡◕‿‿◕｡)づ 适合多人协作开发，各自负责不同API模块。

---

如需更详细的实现或有特殊需求，欢迎随时交流！(づ｡◕‿‿◕｡)づ
